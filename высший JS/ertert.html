<!DOCTYPE html>
<html>
	<head>
		 <meta charset="UTF-8">
		 <title>высший учебник JS</title>
		 <link href="style_dom.css" rel="stylesheet" type="text/css"/>
		
		
	</head>
	<body id="parent57">
<h3> 1 Введение в регулярные выражения</h3><!-- 1 Введение в регулярные выражения -->
<div ><!-- тег области  -->
	<p id="parent1">1</p><!-- тег параграфа  -->
</div>

<h3> 2 Операторы повторения символов в регулярках</h3><!--  2 Операторы повторения символов в регулярках -->
<div ><!-- тег области  -->
	<p id="parent21">1</p><!-- тег параграфа  -->
	<p id="parent22">1</p><!-- тег параграфа  -->
	<p id="parent23">1</p><!-- тег параграфа  -->
	<p id="parent24">1</p><!-- тег параграфа  -->
</div>

<h3> 3 Группирующие скобки в регулярках</h3><!-- 3 Группирующие скобки в регулярках -->
<div ><!-- тег области  -->
	<p id="parent3">3</p><!-- тег параграфа  -->
</div>

<h3> 4 Экранировка спецсимволов в регулярках</h3><!-- 4 Экранировка спецсимволов в регулярках -->
<div ><!-- тег области  -->
	<p id="parent41">1</p><!-- тег параграфа  -->
	<p id="parent42">1</p><!-- тег параграфа  -->
</div>

<h3> 5 Фигурные скобки в регулярных выражения</h3><!-- 5 Фигурные скобки в регулярных выражения -->
<div ><!-- тег области  -->
	<p id="parent5">5</p><!-- тег параграфа  -->
</div>

<h3> 6 Ограничение жадности в регулярках</h3><!-- 6 Ограничение жадности в регулярках -->
<div ><!-- тег области  -->
	<p id="parent6">6</p><!-- тег параграфа  -->
</div>

<h3> 7 Группы символов в регулярных выражениях</h3><!-- 7 Группы символов в регулярных выражениях -->
<div ><!-- тег области  -->
	<p id="parent7">1</p><!-- тег параграфа  -->
	<p id="parent71">1</p><!-- тег параграфа  -->
	<p id="parent72">1</p><!-- тег параграфа  -->
	<p id="parent73">1</p><!-- тег параграфа  -->
	<p id="parent74">1</p><!-- тег параграфа  -->
</div>

<h3> 8 Наборы символов в регулярных выражениях</h3><!-- 8 Наборы символов в регулярных выражениях -->
<div ><!-- тег области  -->
	<p id="parent8">8</p><!-- тег параграфа  -->
</div>

<h3> 9 Инвертирование наборов символов в регулярках</h3><!-- 9 Инвертирование наборов символов в регулярках -->
<div ><!-- тег области  -->
	<p id="parent9">9</p><!-- тег параграфа  -->
</div>

<h3> 10 Особенности кириллицы в регулярках</h3><!-- 10 Особенности кириллицы в регулярках -->
<div ><!-- тег области  -->
	<p id="parent10">10</p><!-- тег параграфа  -->
</div>

<h3> 11 Спецсимволы внутри квадратных скобок</h3><!-- 11 Спецсимволы внутри квадратных скобок -->
<div ><!-- тег области  -->
	<p id="parent11">11</p><!-- тег параграфа  -->
</div>

<h3> 12 Группы символов внутри квадратных скобок</h3><!-- 12 Группы символов внутри квадратных скобок -->
<div ><!-- тег области  -->
	<p id="parent12">12</p><!-- тег параграфа  -->
</div>

<h3> 13 Спецсимволы-исключения внутри квадратных скобок</h3><!-- 13 Спецсимволы-исключения внутри квадратных скобок -->
<div ><!-- тег области  -->
	<p id="parent13">13</p><!-- тег параграфа  -->
</div>

<h3> 14 Символ шляпки внутри квадратных скобок регулярок</h3><!-- 14 Символ шляпки внутри квадратных скобок регулярок -->
<div ><!-- тег области  -->
	<p id="parent14">14</p><!-- тег параграфа  -->
</div>

<h3> 15 Особенности дефиса внутри квадратных скобок</h3><!-- 15 Особенности дефиса внутри квадратных скобок -->
<div ><!-- тег области  -->
	<p id="parent15">15</p><!-- тег параграфа  -->
</div>

<h3> 16 Начало и конец строки в регулярках</h3><!-- 16 Начало и конец строки в регулярках -->
<div ><!-- тег области  -->
	<p id="parent16_1">16_1</p><!-- тег параграфа  -->
	<p id="parent16_2">16_2</p><!-- тег параграфа  -->
		<p id="parent16_3">16_3</p><!-- тег параграфа  -->
</div>

<h3> 17 Команда 'или' в регулярных выражениях</h3><!-- 17 Команда 'или' в регулярных выражениях -->
<div ><!-- тег области  -->
	<p id="parent17">17</p><!-- тег параграфа  -->
</div>

<h3> 18 Метод test в регулярных выражениях</h3><!-- 18 Метод test в регулярных выражениях -->
<div ><!-- тег области  -->
	<p id="parent18">18</p><!-- тег параграфа  -->
</div>

<h3> 19 Метод match с модификатором g</h3><!-- 19 Метод match с модификатором g -->
<div ><!-- тег области  -->
	<p id="parent19">19</p><!-- тег параграфа  -->
	<p id="parent19_1">19</p><!-- тег параграфа  -->
	<p id="parent19_2">19</p><!-- тег параграфа  -->
</div>

<h3> 20 Карманы в методе match в регулярках</h3><!-- 20 Карманы в методе match в регулярках-->
<div ><!-- тег области  -->
	<p id="parent20">20</p><!-- тег параграфа  -->
	<p id="parent20_1">20</p><!-- тег параграфа  -->
	<p id="parent20_2">20</p><!-- тег параграфа  -->
</div>

<h3> 21 Карманы в методе replace в регулярках</h3><!-- 21 Карманы в методе replace в регулярках -->
<div ><!-- тег области  -->
	<p id="parent21_1"></p><!-- тег параграфа  -->
	<p id="parent21_2"></p><!-- тег параграфа  -->
	<p id="parent21_3"></p><!-- тег параграфа  -->
</div>

<h3> 22 Карманы по умолчанию в методе replace </h3><!-- 22 Карманы по умолчанию в методе replace  -->
<div ><!-- тег области  -->
	<p id="parent22_1">22</p><!-- тег параграфа  -->
	<p id="parent22_2">22</p><!-- тег параграфа  -->
</div>

<h3> 23 Карманы в самой регулярке </h3><!-- 23 Карманы в самой регулярке  -->
<div ><!-- тег области  -->
	<p id="parent23_1">23</p><!-- тег параграфа  -->
	<p id="parent23_2">23</p><!-- тег параграфа  -->
</div>

<h3> 24 Несохраняющие скобки в регулярках</h3><!-- 24 Несохраняющие скобки в регулярках  -->
<div ><!-- тег области  -->
	<p id="parent24_1">24</p><!-- тег параграфа  -->
	<p id="parent24_2">24</p><!-- тег параграфа  -->
</div>

<h3> 25 Позитивный и негативный просмотр</h3><!-- 25 Позитивный и негативный просмотр  -->
<div ><!-- тег области  -->
	<p id="parent25_1">25</p><!-- тег параграфа  -->
	<p id="parent25_2">25</p><!-- тег параграфа  -->
</div>

<h3> 26 Коллбэк в методе replace в регулярках</h3><!-- 26 Коллбэк в методе replace в регулярках  -->
<div ><!-- тег области  -->
	<p id="parent26_1">26</p><!-- тег параграфа  -->
	<p id="parent26_2">26</p><!-- тег параграфа  -->
	</div>
	
<h3> 27 Метод search в регулярных выражениях</h3><!-- 27 Метод search в регулярных выражениях  -->
<div ><!-- тег области  -->
	<p id="parent27">27</p><!-- тег параграфа  -->
	</div>
	
	<h3> 28 Метод split в регулярных выражениях</h3><!-- 28 Метод split в регулярных выражениях  -->
<div ><!-- тег области  -->
	<p id="parent28">28</p><!-- тег параграфа  -->
	</div>
	
	<h3> 29 Головоломки в регулярных выражениях</h3><!-- 29 Головоломки в регулярных выражениях -->
<div ><!-- тег области  -->
	<p id="parent29">29</p><!-- тег параграфа  -->
	</div>

	<h3> 30 Псевдомассивы в JavaScript</h3><!-- 30  Псевдомассивы в JavaScript -->
	<div id="parent30"><!-- тег области  -->
	<p >31</p><!-- тег параграфа  -->
	<p >32</p><!-- тег параграфа  -->
	<p >33</p><!-- тег параграфа  -->
	<p >34</p><!-- тег параграфа  -->
	<p >35</p><!-- тег параграфа  -->
	</div>
	
	<h3> 31 Преобразование псевдомассивов в JavaScript</h3><!-- 31 Преобразование псевдомассивов в JavaScript -->
	<div id="parent31"><!-- тег области  -->
	<p >31</p><!-- тег параграфа  -->
	<p >32</p><!-- тег параграфа  -->
	<p >33</p><!-- тег параграфа  -->
	<p >34</p><!-- тег параграфа  -->
	<p >35</p><!-- тег параграфа  -->
	</div>
	
	<div id="parent31_1"><!-- тег области  -->
	<p >31</p><!-- тег параграфа  -->
	<p >32</p><!-- тег параграфа  -->
	<p >33</p><!-- тег параграфа  -->
	<p >34</p><!-- тег параграфа  -->
	<p >35</p><!-- тег параграфа  -->
	</div>
	
	<h3> 32 Типы псевдомассивов в JavaScript</h3><!-- 32 Типы псевдомассивов в JavaScript -->
	<div id="parent32"><!-- тег области  -->
	<p >31</p><!-- тег параграфа  -->
	<p >32</p><!-- тег параграфа  -->
	<p >33</p><!-- тег параграфа  -->
	<p >34</p><!-- тег параграфа  -->
	<p >35</p><!-- тег параграфа  -->
	</div>
	
	<h3> 33 Коллекции Map</h3><!-- 33 Коллекции Map -->
	<div id="parent33"><!-- тег области  -->
	</div>
	
	<h3> 34 Полезные свойства и методы коллекций Map</h3><!-- 34 Полезные свойства и методы коллекций Map -->
	<div id="parent34"><!-- тег области  -->
	</div>
	<div id="parent34_1"><!-- тег области  -->
	</div>

	<h3> 35 Перебор коллекций Map</h3><!-- 35 Перебор коллекций Map -->
	<div id="parent35"><!-- тег области  -->
	</div>
	
	<h3> 36 Отделение ключей и значений в коллекциях Map</h3><!-- 36 Отделение ключей и значений в коллекциях Map -->
	<div id="parent36"><!-- тег области  -->
	</div>
	
	<h3> 37 Применение коллекций Map</h3><!-- 37 Применение коллекций Map -->
	<div id="parent37"><!-- тег области  -->
	<p>aaa</p>
	<p>bbb</p>
	<p>ccc</p>
	<p>ddd</p>
	<p>eee</p>
	</div>
	
	<h3> 38 Коллекции Set</h3><!-- 38 Коллекции Set -->
	<div id="parent38">
		</div>
		
	<h3> 39 Полезные свойства и методы коллекций Set</h3><!-- 39 Полезные свойства и методы коллекций Set -->
	<div id="parent39">
	</div>
		
	<h3> 40 Перебор коллекций Set циклом</h3><!-- 40 Перебор коллекций Set циклом -->
	<div id="parent40">
	</div>
		
	<h3> 41 Преобразование коллекций Set</h3><!-- 41 Преобразование коллекций Set -->
	<div id="parent41_1">
	</div>
	<div id="parent41_2">
	</div>
	
	<h3> 42 Удаление дублей с помощью коллекций Set</h3><!-- 42 Удаление дублей с помощью коллекций Set -->
<div id="parent42_2">
<p>aaa</p>
<p>bbb</p>
<p>ccc</p>
<p>ddd</p>
<p>eee</p>
</div>

<button id="parent42_3"> click me</button>

<h3> 43 Массивы ArrayBuffer</h3><!-- 43 Массивы ArrayBuffer -->
<div id="parent43">
	</div>
	
	<h3> 44 Итераторы</h3><!-- 44 Итераторы -->
<div id="parent44">
	</div>
	
	<h3> 50 Хранение массивов и объектов в локальном хранилище</h3><!-- 50 Хранение массивов и объектов в локальном хранилище -->
имя
<input id="elem50_1" value="345"><br/><!-- область ввода -->
фамилия
<input id="elem50_2" value="вап"><br/><!-- область ввода -->
отчество
<input id="elem50_3" value="п34"><br/><!-- область ввода -->
<input id="elem50_4" type="submit"value="Старт"><!-- кнопка -->

<h3> 53 Выбрасывание исключительных ситуаций </h3><!-- 53 Выбрасывание исключительных ситуаций  -->
<!--<div id="product53" data-product53="яблоко" data-price53="1000" data-amount53="0"></div>-->
<div id="product53" data-product53="яблоко" data-price53="1000"></div> 
	<script>
	//_________________________________________________			
// 	1 ВВЕДЕНИЕ В РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
//Регулярные выражения - это такие команды для сложного поиска и замены (или просто поиска).
//Метод replace применяется для замены элементов в строке, первым параметром принимает что менять, 
//а вторым - на что менять. А сам метод применяется к строке, в которой производится замена
	let m1 = 'Xурок' // объявляем переменную со строкой 
	let result11 = m1.replace('X', '1'); // к строке применяем метод replace имеющий 2 парамета 
	//(1 что меняем, 2 на что меняем) 
	console.log (result11); // вернет в консоль '1урок'
//Первым параметром этого метода можно передавать не просто строку, а регулярное выражение. 
//Регулярное выражение представляет собой набор команд, расположенных внутри слешей /. 
//Эти слеши называются ограничителями регулярных выражений.	
//Сами регулярные выражения состоят из двух типов символов: из тех, которые обозначают сами себя и из 
//символов-команд, которые называются специальные символы.
let result12 =  m1.replace(/X/, '11');// к строке применяем метод replace имеющий 2 парамета 
console.log (result12);// вернет в консоль '11урок'
//точка является специальным символом и обозначает любой символ.
console.log ('xуйня eee'.replace(/x...я/, '.i.')); // вернет '.i. eee'
//После ограничителей можно писать модификаторы - команды, которые изменяют общие свойства регулярного выражения. 
//Например, модификатор g включает режим глобального поиска и замены - без него регулярка ищет только первое совпадение,
// а с ним - все совпадения.
console.log ('aab'.replace(/a/,  '!')); // вернет '!ab'
console.log ('aab'.replace(/a/g, '!')); // вернет '!!b'
let parent_1 = document.querySelector('#parent1');//передаем в переменную значение параграфа
parent_1.innerHTML = 'aab'.replace(/a/g, '!')// в значение параграфа записываем регулярное выражение, результат которого '!!b'
	
	//_________________________________________________			
// 	2 ОПЕРАТОРЫ ПОВТОРЕНИЯ СИМВОЛОВ В РЕГУЛЯРКАХ
//Для определения повторения один или более раз используют операторы (квантификаторы) повторения: плюс + (один и более раз), 
//звездочка * (ноль или более раз) и вопрос ? (ноль или один раз). Эти операторы действуют на тот символ, который стоит перед ними.
let parent_21 = document.querySelector('#parent21');//передаем в переменную значение параграфа
let parent_22 = document.querySelector('#parent22');//передаем в переменную значение параграфа
let parent_23 = document.querySelector('#parent23');//передаем в переменную значение параграфа
let parent_24 = document.querySelector('#parent24');//передаем в переменную значение параграфа
let str2 = 'xx xax xaax xaaax xbx'; // объявляем переменную со строкой 
let res21 = str2.replace(/xa+x/g, '!');//выведет 'xx ! ! ! xbx'
parent_21.innerHTML = res21//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
let res22 = str2.replace(/xa*x/g, '!');//выведет '! ! ! ! xbx'
parent_22.innerHTML = res22//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
let res23 = str2.replace(/xa?x/g, '!');//выведет '! ! xaax xbx'
parent_23.innerHTML = res23//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
let res24 = str2.replace(/a.x/g, '!');//выведет 'xx xax x! xa! xbx' - заменил "aax" на !
parent_24.innerHTML = res24//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения

	//_________________________________________________			
// 	3 ГРУППИРУЮЩИЕ СКОБКИ В РЕГУЛЯРКАХ
//если мы хотим подействовать им на несколько символов для этого существуют группирующие скобки '(' и ')'. 
//Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, 
//что стоит внутри скобок.
	let parent_3 = document.querySelector('#parent3');//передаем в переменную значение параграфа
	let str3 = 'ab abab abab abababab abea'// объявляем переменную со строкой 
let res3 = str3.replace(/(ab)+/g, '!');// к строке применяем метод replace имеющий 2 парамета (имеет (ab)+)
parent_3.innerHTML = res3  //выведет ! ! ! ! !ea

	//_________________________________________________			
// 4 ЭКРАНИРОВКА СПЕЦСИМВОЛОВ В РЕГУЛЯРКАХ
//чтобы спецсимвол обозначал сам себя, для этого его нужно экранировать с помощью обратного слеша.
let parent_41 = document.querySelector('#parent41');//передаем в переменную значение параграфа
let parent_42 = document.querySelector('#parent42');//передаем в переменную значение параграфа
	let str4 = 'a+x ax aax aaax'// объявляем переменную со строкой 
	let res41 = str4.replace(/a+x/g, '!');//выведет 'a+x ! ! !'
	parent_41.innerHTML = res41//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
	let res42 = str4.replace(/a\+x/g, '!'); //выведет '! ax aax aaax'
	parent_42.innerHTML = res42//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
//Если экранировать обычный символ - ничего страшного не случится - он все равно будет обозначать сам себя. 
//Исключение - цифры, их нельзя экранировать. Часто возникает сомнение, является ли данный символ специальным. 
//Некоторые доходят до того, что экранируют все подозрительные символы подряд. Однако, это плохая практика 
//(захламляет регулярку обратными слешами).
//Являются спецсимволами: $ ^ . * + ? \ / {} [] () |
//Не являются спецсимволами: @ : , ' " ; - _ = < > % # ~ `& !

	//_________________________________________________			
// 5 ФИГУРНЫЕ СКОБКИ В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ
//Операторы '+', '*', '?' хороши, однако, с их помощью нельзя указать конкретное число повторений. 
//В этом случае вам на помощь придет оператор {}. Работает он следующим образом: {5} - пять повторений,
// {2,5} – повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз. 
//Обратите внимание на то, что такого варианта - {,2} - нет.
let parent_5 = document.querySelector('#parent5');//передаем в переменную значение параграфа
let str5 = 'xx xax xaax xaaax';/// объявляем переменную со строкой 
let res5 = str5.replace(/xa{1,2}x/g, '!');//выведет 'xx ! ! xaaax'
parent_5.innerHTML = res5////в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
	
	//_________________________________________________			
// 6 ОГРАНИЧЕНИЕ ЖАДНОСТИ В РЕГУЛЯРКАХ
//let str = 'aeeex zzz x kkk';
//let res = str.replace(/a.+x/g, '!');
//Мы ожидаем, что в переменную res в результате запишется строка '! zzz x kkk'. Однако, это не так - в переменную попадает строка '! kkk'.
//let res = str.replace(/a.+x/g, '!');
//Все дело в том, что наша регулярка ищет все символы от буквы 'a' до буквы 'x'. Но в нашей строке две буквы 'x'! Из-за жадности получается, 
//что регулярка ищет до самого последнего икса, тем самым захватывая не то, что мы ожидали. Чтобы ограничить жадность, нужно после оператора 
//повторения поставить знак вопроса
let parent_6 = document.querySelector('#parent6');//передаем в переменную значение параграфа
let str6 = 'aeeex zzz x kkk';// объявляем переменную со строкой 
let res6 = str6.replace(/a.+?x/g, '!'); //передает значение строку '! zzz x kkk'
parent_6.innerHTML = res6//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения

	//_________________________________________________			
// 7 ГРУППЫ СИМВОЛОВ В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ
//Существуют специальные команды, которые позволяют выбрать сразу целые группы символов. Команда \d означает цифру от 0 до 9. 
//Команда \w обозначает цифру, латинскую букву или знак подчеркивания. Команда \s обозначает пробел или пробельный символ: пробел, 
//перевод строки, табуляцию. Можно инвертировать значение команды, написав большую букву: например, если \d - цифра, то \D - не цифра.
let parent_7 = document.querySelector('#parent7');//передаем в переменную значение параграфа
let parent_71 = document.querySelector('#parent71');//передаем в переменную значение параграфа
let parent_72 = document.querySelector('#parent72');//передаем в переменную значение параграфа
let parent_73 = document.querySelector('#parent73');//передаем в переменную значение параграфа
let parent_74 = document.querySelector('#parent74');//передаем в переменную значение параграфа
let str7 = '1 12 123 abc @@@';// объявляем переменную со строкой 
let res7 = str7.replace(/\d/g, '!'); //передает значение строку '! !! !!! abc @@@' (заменяет числа)
parent_7.innerHTML = res7//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
let res71 = str7.replace(/\D+/g, '!'); //передает значение строку '1!12!123!' (заменяет все не числа)
parent_71.innerHTML = res71//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
let res72 = str7.replace(/\s/g, '!'); //передает значение строку '1!12!123!abc!@@@' (заменяет пробелы)
parent_72.innerHTML = res72//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
let res73 = str7.replace(/\S+/g, '!'); //передает значение строку '! ! ! ! !' (заменяет все не пробелы)
parent_73.innerHTML = res73//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения
let res74 = str7.replace(/\w+/g, '!'); //передает значение строку '! ! ! ! @@@' (заменяет цифру и латинские буквы, оставляя спецсимвалы)
parent_74.innerHTML = res74//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения

	//_________________________________________________			
// 8 НАБОРЫ СИМВОЛОВ В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ
//Группы символов \d и \w не очень гибкие. Даже такая простая задача, как найти все буквы, но не цифры - не может быть решена ими. 
//Для таких задач следует использовать квадратные скобки, представляющие собой операцию 'или'. Квадратные скобки заменяют собой один символ, 
//любой из перечисленных внутри. К примеру, вот так: /x[abc]x/ - мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: 
//или 'a', или 'b', или 'c'.
//После квадратных скобок можно писать операторы повторения. К примеру, вот так: /x[abc]+x/ - мы говорим, что внутри иксов может быть 
//любое количество символов 'a', 'b' и 'c' 
//- в любых комбинациях. Можно не только перечислять символы, но создавать группы символов, записывая между двумя символами дефис. 
//К примеру, вот так: [a-d] - мы получаем все символы от 'a' до 'd'.
let parent_8 = document.querySelector('#parent8');//передаем в переменную значение параграфа
let str8 = 'xax xbx xcx x@x';// объявляем переменную со строкой 
let res8 = str8.replace(/x[a-z]x/g, '!'); //передаем в переменную строку '! ! ! x@x' (заменяет все буквы в границах от Х до Х в диапазоне 
//от A до Z несколько раз подрят 
parent_8.innerHTML = res8//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет '! ! ! x@x'
	
	//_________________________________________________			
// 9 ИНВЕРТИРОВАНИЕ НАБОРОВ СИМВОЛОВ В РЕГУЛЯРКАХ
//С помощью шляпки '^' в начале квадратных скобок можно инвертировать желаемое. 
//То есть, если, к примеру, команда [ab] ищет букву 'a' или 'b', то команда [^ab] будет искать все символы, кроме 'a' и 'b'.
	let parent_9 = document.querySelector('#parent9');//передаем в переменную значение параграфа
	let str9 = 'xaz xbz xcz xez';// объявляем переменную со строкой 
let res9 = str9.replace(/x[^abc]z/g, '!'); //в переменную передаем 'xax xbx xcx !'
parent_9.innerHTML = res9//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет 'xax xbx xcx !'
	
	//_________________________________________________			
// 10 ОСОБЕННОСТИ КИРИЛИЦЫ В РЕГУЛЯРКАХ
//Кириллические символы не входят в группу \w. Для их получения нужно использовать группу в квадратных скобках, вот так: [а-я]. 
//Но даже с этой группой есть проблема - сюда не войдет буква 'ё'. Для ее включения нужно сделать вот так: [а-яё].
	let parent_10 = document.querySelector('#parent10');//передаем в переменную значение параграфа
	let str10 = 'wйw wяw wёw wqw';// объявляем переменную со строкой 
	let res10 = str10.replace(/w[а-яё]w/g, '!'); //в переменную передаем '! ! ! wqw'
	parent_10.innerHTML = res10//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет '! ! ! wqw'
	
	//_________________________________________________			
// 11 СПЕЦСИМВОЛЫ ВНУТРИ КВАДРАТНЫХ СКОБОК
//Спецсимволы внутри [ ] становятся обычными символами. Это значит, что их не надо экранировать обратным слешем.
let parent_11 = document.querySelector('#parent11');//передаем в переменную значение параграфа
let str11 = 'xax xbx xcx xdx x.x x@x';// объявляем переменную со строкой 
let res11 = str11.replace(/x[abc.@]x/g, '!');//в переменную передаст ' ! ! ! xdx ! !' 
//(шаблон поиска выглядит так: между иксами любая буква 'a', 'b', 'c', либо точка, либо собачка
parent_11.innerHTML = res11//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет '! ! ! xdx ! !'

	//_________________________________________________			
// 12 ГРУППЫ СИМВОЛОВ ВНЕУТРИ КВАДРАТНЫХ СКОБОК
//Группы символов \d, \D, \w, \W, \s, \S внутри [ ] будут обозначать именно группы, то есть по-прежнему будут командами.
let parent_12 = document.querySelector('#parent12');//передаем в переменную значение параграфа
let str12 = 'xaz x1z xAz x.z x@z';// объявляем переменную со строкой 
let res12 = str12.replace(/x[^\d.a-z]z/g, '!');//в переменную передаст 'xaz x1z ! x.z !'
//(шаблон поиска выглядит так: буква 'x', затем не цифра (- команда \d) , не точка, и не маленькая латинская буква, затем буква 'z'
parent_12.innerHTML = res12//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет 'xaz x1z ! x.z !'

	//_________________________________________________			
// 13 СПЕЦСИМВОЛЫ-ИСКЛЮЧЕНИЯ ВНУТРИ КВАДРАТНЫХ СКОБОК
//спецсимволы внутри [ ] становятся обычными символами. Есть, однако, исключения: если вам нужны квадратные скобки как символы внутри [ ] 
//- то их нужно экранировать обратным слешем.
let parent_13 = document.querySelector('#parent13');//передаем в переменную значение параграфа
let str13 = 'x]x xax x[x x1x';// объявляем переменную со строкой 
let res13 = str13.replace(/x[\]\[]x/g, '!');//лучше писать наоборот (/x[\[\]]x/g, '!' - визуально понятнее), //в переменную передаст '! xax ! x1x'
parent_13.innerHTML = res13//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет '! xax ! x1x'

	//_________________________________________________			
// 14 СИМВОЛ ШЛЯПКИ ВНУТРИ КВАДРАТНЫХ СКОБОК РЕГУЛЯРОК
//шляпка внутри [ ] делает отрицание, будучи написанной в начале скобок. Значит, она является спецсимволом внутри этих скобок. 
//Чтобы получить шляпку как символ, нужно или заэкранировать ее, или убрать с первого места - let res = str.replace(/[d^]xx/g, '!');
let parent_14 = document.querySelector('#parent14');//передаем в переменную значение параграфа
let str14 = 'axx bxx ^xx dxx';// объявляем переменную со строкой 
let res14 = str14.replace(/[\^d]xx/g, '!');// -'экранируем \^ (в результате получим строка начинающаяся с  ^ или d и заканчивающаяся ХХ )
 //передаем в переменную 'axx bxx ! !'
parent_14.innerHTML = res14//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет 'axx bxx ! !'

	//_________________________________________________			
// 15 ОСОБЕННОСТИ ДЕФИСА ВНУТРИ КВАДРАТНЫХ СКОБОК
//Дефис - тоже спецсимвол внутри [ ] (а вот снаружи - нет). Если вам нужен сам дефис как символ - то поставьте его там, 
//где он не будет воспринят как разделитель группы. Почему это важно: вы можете сделать группу символов, сами не заметив этого.
// К примеру, вот так - '[:-@]' - вы думаете, что выбираете двоеточие, дефис и собаку, а на самом деле получается группа символов между : и @.
// В эту группу входят следующие символы: : ; ? < = > Из таблицы ASCII - двоеточие имеет номер меньше, чем собака - и получается группа. 
//То есть все группы получаются по таблице ASCII (при желании этим можно пользоваться). ак с этим бороться: поставьте символ дефиса там, 
//где он точно не будет воспринят как символ группы, например, в начале или в конце (то есть после [или перед ]). Можно также заэкранировать дефис 
//- тогда он будет обозначать сам себя независимо от позиции. Например, вместо [:-@] написать [:\-@] - и группы уже не будет, а будут три символа 
//- двоеточие, дефис и собака @.
let parent_15 = document.querySelector('#parent15');//передаем в переменную значение параграфа
let str15 = '1a2 1-2 1c2 1z2';// объявляем переменную со строкой 
let res15 = str15.replace(/1[a\-z]2/g, '!');// в переменную передаст строку с заменой '! ! 1c2 !'
parent_15.innerHTML = res15//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет '! ! 1c2 !'

	//_________________________________________________			
// 16 НАЧАЛО И КОНЕЦ СТРОКИ В РЕГУЛЯРКАХ
//Существуют специальные символы, которые обозначают начало '^' или конец строки '$'.
//Когда в начале регулярки стоит '^', а в конце - '$', то таким образом мы проверяем всю строку целиком на соответствие регулярке.
let parent_16_2 = document.querySelector('#parent16_2');//передаем в переменную значение параграфа
let parent_16_1 = document.querySelector('#parent16_1');//передаем в переменную значение параграфа
let parent_16_3 = document.querySelector('#parent16_3');//передаем в переменную значение параграфа
let str16 = 'aaa aaa aaa';// объявляем переменную со строкой 
let res16_1 = str16.replace(/^aaa/g, '!');// в переменную передаст строку с заменой '! aaa aaa'
let res16_2 = str16.replace(/aaa$/g, '!');// в переменную передаст строку с заменой 'aaa aaa !'
let res16_3 = str16.replace(/^aaa$/g, '!');// в переменную передаст строку с заменой 'aaa aaa aaa'
parent_16_1.innerHTML = res16_1//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет '! aaa aaa'
parent_16_2.innerHTML = res16_2//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет 'aaa aaa !'
parent_16_3.innerHTML = res16_3//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет ' aaa aaa aaa'

	//_________________________________________________			
// 17 КОМАНДА ИЛИ В РЕКГУЛЯРНЫХ ВЫРАЖЕНИЯХ
//Команда '|',  представляет собой более мощный вариант 'или' по сравнению с командой [ ]. Позволяет разделить регулярку на несколько частей.
// При этом искомое может попасть либо под одну часть регулярки, либо под другую. 
let str17 = 'aaa bbb abb';
let parent_17 = document.querySelector('#parent17');//передаем в переменную значение параграфа
let res17 = str17.replace(/a{3}|b{3}/g, '!');//в переменную передаст строку с заменой '! ! abb'
parent_17.innerHTML = res17 //в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения, выведет '! ! abb'

	//_________________________________________________			
// 18 МЕТОД test В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ
//В данном уроке мы с вами рассмотрим метод test, который проверяет, есть ли в строке хотя бы одно совпадение с регуляркой. 
//Если есть - возвращается true, а если нет - false. Метод параметром принимает строку, а применяется к регулярке, вот так: регулярка.test(где искать).
let parent_18 = document.querySelector('#parent18');//передаем в переменную значение параграфа
parent_18.innerHTML = /a+/.test('eee aaa bbb'); // вернет true применив метод test

	//_________________________________________________			
// 19 МТОД match с модификатором g 
// Метод match позволяет получить ту часть строки, которая попала под регулярное выражение. Этот метод работает по-разному в зависимости от того, 
//есть модификатор g или нет. Если он есть - метод возвращает массив подстрок, которые попали под регулярное выражение.
//Если же совпадений нет, то возвращает null.
let parent_19 = document.querySelector('#parent19');//передаем в переменную значение параграфа
let parent_19_1 = document.querySelector('#parent19_1');//передаем в переменную значение параграфа
let parent_19_2 = document.querySelector('#parent19_2');//передаем в переменную значение параграфа
let str19 = 'a aa abba abaa';// объявляем переменную со строкой 
parent_19.innerHTML = str19.match(/a+/g);//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения,
//выведет 'a,aa,a,a,a,aa'
let str19_1 = '1 23 456 789';// объявляем переменную со строкой 
parent_19_1.innerHTML= str19_1.match(/\d/g);//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения,
//только числа, выведет '1,2,3,4,5,6,7,8,9'
parent_19_2.innerHTML = str19_1.match(/\d+/g);//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения,
//только числа, выведет '1,23,456,789'

	//_________________________________________________			
// 20 КАРМАНЫ В МЕТОДЕ math В РЕГУЛЯРКАХ
//Если вызвать метод match без модификатора g, то он найдет только первое совпадение с регуляркой. Однако, вернет он все равно массив - 
//это будет массив, состоящий из найденного совпадения, с дополнительными свойствами: index - позиция, на которой оно обнаружено и input - строка,
// в которой был поиск. А найденная подстрока будет лежать в нулевом элементе возвращенного массива
let parent_20 = document.querySelector('#parent20');//передаем в переменную значение параграфа
let parent_20_1 = document.querySelector('#parent20_1');//передаем в переменную значение параграфа
let parent_20_2 = document.querySelector('#parent20_2');//передаем в переменную значение параграфа
let str20 = 'zzz xaaax xaaaax xaaaaax';// объявляем переменную со строкой 
parent_20.innerHTML = str20.match(/xa+x/);//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения,
console.log (parent_20.innerHTML)//в консоль выведет значение параграфа к которому применился метод match - выведет 'xaaax'
parent_20_1.innerHTML = str20.match(/xa+x/).index;//в тег параграфа передаем значение от переменной с регулярным выражением и примененным свойством index,
// заменяющий значения - выведет 4
parent_20_2.innerHTML = str20.match(/xa+x/).input;//в тег параграфа передаем значение от переменной с регулярным выражением и примененным свойством input,
// заменяющий значения - выведет всю строку 'zzz xaaax xaaaax xaaaaax'

	//_________________________________________________			
// 21 КАРМАНЫ В МЕТОДЕ replace В РЕГУЛЯРКАХ
//Метод replace умеет использовать так называемые "карманы". То есть есть возможность обратиться к найденным вариациям внутри метода.
//Эти карманы появляются, если использовать скобки ( ). Их можно подставлять во второй параметр функции, используя порядковый номер и знак $. 
//Таким образом можно заменять части строки так, что содержащиеся в кармане части будут подставляться на замену.
let parent_21_1 = document.querySelector('#parent21_1');//передаем в переменную значение параграфа
let parent_21_2 = document.querySelector('#parent21_2');//передаем в переменную значение параграфа
let parent_21_3 = document.querySelector('#parent21_3');//передаем в переменную значение параграфа
let str21_1 = '1 23 456 xad';// объявляем переменную со строкой 
parent_21_1.innerHTML = str21_1.replace(/(\d+)/g, '($1)');//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения,
// выведет '(1) (23) (456) xad', заменит все числа на числа теже но со скобкой
parent_21_2.innerHTML = str21_1.replace(/(\d+)/g, '!$1!');//в тег параграфа передаем значение от переменной с регулярным выражением, заменяющий значения,
// выведет !1! !23! !456! xad , заменит все числа на числа теже но с !
parent_21_3.innerHTML = str21_1.replace(/([a-z]+)a([a-z]+)/g, '$2a$1');//в тег параграфа передаем значение от переменной с регулярным выражением, 
//заменяющий значения, выведет '1 23 456 dax' , передали в карман все выражение при совподение должен поменять части выражения местами

	//_________________________________________________			
// 22 КАРМАНЫ ПО УМОЛЧАНИЮ В МЕТОДЕ replace 
//В методе replace, помимо карманов с вашими номерами, всегда доступны также стандартные карманы: $& - всё найденное совпадение, $` и $' -часть 
//строки до и после совпадения. Давайте посмотрим работу с ними на примерах.
let parent_22_1 = document.querySelector('#parent22_1');//передаем в переменную значение параграфа
let parent_22_2 = document.querySelector('#parent22_2');//передаем в переменную значение параграфа
let str22_1 = '1 23 456';// объявляем переменную со строкой 
let str22_2 = '123@456';// объявляем переменную со строкой 
let res22_1 = str22_1.replace(/\d+/g, '($&)');//в переменную передаем значение от переменной с регулярным выражением, заменяющий значения,
parent_22_1.innerHTML = res22_1 //в тег параграфа передаем значение от переменной (1) (23) (456) - карман обернули в скобки, только числа
let res22_2 = str22_2.replace(/@/g, "($'@$`)")//в переменную передаем значение от переменной с регулярным выражением, заменяющий значения,,
parent_22_2.innerHTML = res22_2//в тег параграфа передаем значение от переменной  123(456@123)456 - @ заменили на выражение из $'@$`

	//_________________________________________________			
// 23 КАРМАНЫ В САМОЙ РЕГУЛЯРКЕ
//Содержимое карманов доступно не только в строке замены, но в и самой регулярке
//Можно обращаться к содержимому кармана непосредственно в регулярном выражении. То есть в карман заносятся данные и тут же достаются.
// Для этого необходимо поставить слеш \ и затем номер кармана непосредственно в регулярном выражении
//Содержимое карманов доступно по их номерам, перед которыми стоит обратный слеш. Например, первый карман будет доступен вот так:
// \1, второй карман вот так - \2, третий - \3 и так далее.
let parent_23_1 = document.querySelector('#parent23_1');//передаем в переменную значение параграфа
let parent_23_2 = document.querySelector('#parent23_2');//передаем в переменную значение параграфа
 let str23_1 = 'aaa bbb cd ee';// объявляем переменную со строкой 
  let str23_2 = 'aaaca buzxb csgd';// объявляем переменную со строкой 
parent_23_1.innerHTML = str23_1.replace(/([a-z])\1/g, '!');// выведет '!a !b cd !', выражение заменяет регулярку на ! -  в которых стоят две любые 
//одинаковые буквы подряд,([a-z]) буква в кармане, \1 первый карман 
parent_23_2.innerHTML = str23_2.replace(/([a-z])[a-z]+\1/g, '!');//выведет '! ! csgd', заменяет часть строки обзначающую - буква в кармане, 
//затем еще одна или болеебукв, а затем такая же буква как первая

	//_________________________________________________			
// 24 НЕСОХРАНЯЮЩИЕ СКОБКИ В РЕГУЛЯРКАХ
//Скобки ( ) выполняют две функции - группировка символов и функцию кармана. А что делать, если нам нужно сгруппировать, но в карман не класть?
//Для решения такой проблемы придуманы специальные несохраняющие скобки (?: ) - они группируют, но не кладут в карман.
let parent_24_1 = document.querySelector('#parent24_1');//передаем в переменную значение параграфа
let parent_24_2 = document.querySelector('#parent24_2');//передаем в переменную значение параграфа
let str24_1 = 'abab123';// объявляем переменную со строкой 
parent_24_1.innerHTML = str24_1.match(/(ab+)+([1-9]+)/); //выведет 'abab123,ab,123' 
parent_24_2.innerHTML = str24_1.match(/(?:ab+)+(?:[1-9]+)/); //выведет 'abab123' 

	//_________________________________________________			
// 25 ПОЗИТИВНЫЙ И НЕГШАТИВНЫЙ ПРОСМОТР

//Позитивный просмотр вперед
//Для решения задачи нужен способ сказать, что 'x' не следует заменять. Делается это с помощью специальных скобок (?= ),
//которые просто смотрят, но не забирают с собой. Эти скобки называются позитивный просмотр вперед. Позитивный - так как 'x' (в нашем случае) 
//должен быть - только тогда произойдет замена.
//Эти скобки называются позитивный просмотр вперед. Позитивный - так как 'x' (в нашем случае) должен быть - только тогда произойдет замена.
let parent_25_1 = document.querySelector('#parent25_1');//передаем в переменную значение параграфа
let parent_25_2 = document.querySelector('#parent25_2');//передаем в переменную значение параграфа
let str25_1 = 'aaax baaa';// объявляем переменную со строкой 
parent_25_1.innerHTML = str25_1.replace(/aaa(?=x)/g, '!'); // вернет '! baaa',  ? (обозначает 0 или один раз)

//Негативный просмотр вперед
//Есть и негативный просмотр вперед - (?! ) - он, наоборот, говорит, что чего-то должно не быть:
parent_25_2.innerHTML = str25_1.replace(/aaa(?!x)/g, '!'); // вернет 'aaax !b', ?! (обозначает не 0 или один раз)

	//_________________________________________________			
// 26 КОЛБЭК В МЕТОДЕ replace В РЕГУЛЯРКАХ
//Метод replace вторым параметром может принимать не только строку, но и функцию-коллбэк, которая применится для каждого найденного совпадения. 
//Каждая подстрока, которую нашла регулярка, заменится на то, что вернет эта функция именно для этой подстроки.
//В эту функцию можно передавать параметры: в первый параметр положится найденная строка, во второй параметр - первый карман,
// в третий параметр - второй карман и так далее - можно делать сколько параметров, сколько карманов в регулярном выражении.
//В предпоследний параметр положится позиция найденного совпадения, а в последний - вся строка, по которой делается поиск.
let parent_26_1 = document.querySelector('#parent26_1');//передаем в переменную значение параграфа
let str26_1  = 'a 2 3 4 5';// объявляем переменную со строкой 
let result26_1 = str26_1.replace(/\d+/g, function(match) {// передаем в параметр функцию колбека в котором параметр - элемент подподающий в регулярку 
return(match);// результат исполнения функции колбека - поочередная замена (подставление в колбэк) элементов строки и вывод через return
});
parent_26_1.innerHTML = result26_1 //выведет 'a 2 3 4 5'
let parent_26_2 = document.querySelector('#parent26_2');//передаем в переменную значение параграфа
let str26_2 = '2+3= 4+5= 6+7=';// объявляем переменную со строкой 
let result26_2 = str26_2.replace(/(\d+)\+(\d+)=/g, function(match26_0, match26_1, match26_2) { // передаем в параметр метода replace регулярку и 
//колбэк с 3 параметрами ( в параметры передадуца все совподающие подстроки и соданные карманы )
	let sum26 = Number(match26_1) + Number(match26_2); // в переменную передаем сумму значений строк карманов
	return match26_0 + sum26;// складываем первое значение найденной подстроки и переменную со сложением значений колбэков
});
parent_26_2.innerHTML = result26_2;// передаем переменную со результатом замененной строки в тег параграфа

	//_________________________________________________			
// 27 МЕОД search В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ 
//Метод search - осуществляет поиск в строке по регулярному выражению. Он принимает следующие параметры: строка.search(регулярка), а возвращает позицию
// первой найденной подстроки, а если она не найдена - то -1.

let parent_27 = document.querySelector('#parent27');//передаем в переменную значение параграфа
let str27 = 'a aa aaa aaaa aaaa';// объявляем переменную со строкой 
let str27_1 = str27.match(/a+/g);//передаем в переменную значение параграфа с примененным медом match позволяющий вывести часть строки которая подпадает 
//выведет 'a', 'aa', 'aaa', 'aaaa', 'aaaa'
for (let i = 0; i < str27_1 .length; i++)// цикл для определения длинны массива
{
if ( str27_1[i].length == 3)//условие если длинна подмассива равна 3 то 
{
let res27 = str27.search(/aaa/);// в переменную передасца искомая часть подмассива
parent_27.innerHTML = (str27_1[i] +'='+ res27) //в параграф передасца aaa=5
}
}

	//_________________________________________________			
// 28 МЕОД split В РЕГУЛЯРНЫХ ВЫРАЖЕНИЯХ 
//Метод split разбивает строку в массив по разделителю, разделитель передается параметром и им является строка.
//Это однако не всегда так - параметром можно передать и регулярное выражение. В этом случае разделителем будет выступать все подстроки, 
//которые попали под регулярное выражение.
let parent_28 = document.querySelector('#parent28');//передаем в переменную значение параграфа

let str28 = 'a-b+c-d+e';// объявляем переменную со строкой 
parent_28.innerHTML = str28.split(/[-+]/);//разбиваем строку методом split в параметр которого передаем регулярное выражение обозначающее разделитель 
	
	//_________________________________________________			
// 29 ГОЛОВОЛОМКИ В РЕГУЛЯРКАХ
//Определите, что год находится в интервале от 1900 до 2100 с помощью одного только регулярного выражения.
let parent_29 = document.querySelector('#parent29');//передаем в переменную значение параграфа
let str29 = '2055';// объявляем переменную со строкой 
parent_29.innerHTML = str29.match(/(?:[1-2][0|9]..)|2100/); //выведет '2055' 

	//_________________________________________________			
// 30 ПСЕВДОМАССИВЫ В JS
let  elems30 = document.querySelectorAll('#parent30 p');//получаем массив с ячейками
console.log(elems30[0].innerHTML);//выводим в консоль значение элемента псевдомассива
console.log(elems30[1].innerHTML);//выводим в консоль значение элемента псевдомассива
console.log(elems30[2].innerHTML);//выводим в консоль значение элемента псевдомассива
console.log(elems30.length);//выводим в консоль значение длинны массива
for (let elem30 of elems30) {//перебираем псевдомассив
	console.log(elem30.innerHTML);//выводим в консоль значение элементов псевдомассива
}
//Хотя псевдомассивы и похожи на массивы, но все же это обычные объекты. У них нет свойств и методов массивов, таких как forEach, join, slice и других
//Существует специальный метод Array.isArray, который возвращает true, если параметром ему передан массив, и false в остальных случаях:
let test30 = [1, 2, 3];// записываем в переменную массив
console.log(Array.isArray(test30)); // выведет true, проверка на состояние массива
console.log(Array.isArray(elems30)); // выведет false,  проверка на состояние массива

//_________________________________________________			
// 31 ПРЕОБРАЗОВАНИЕ ПСЕВДОМАССИВОВ В JS
//Способ первый, перебрать наш псевдомассив циклом, формируя в этом цикле новый массив
let  elems31 = document.querySelectorAll('#parent31 p');//получаем массив с ячейками
let arr31 = [];//объявляем пустой массив
for (let elem31 of elems31) {// псевдомассив перебираем циклом 
	arr31.push(elem31.innerHTML);//записываем в новый массив значения перебираемых элементов
}
console.log (arr31)// выводим новый массив в консоль 

//Способ второй, можно воспользоваться деструктуризацией и оператором rest
let elems31_1 = document.querySelectorAll('#parent31_1 p');//получаем массив с ячейками
let arr31_1 = [...elems31_1];// заполняем массив деструктуризацией и оператором rest
let m31 = arr31_1.length//в переменную передаем длинну массива
console.log (m31)//выводис длинну в консоль
for (i=0; i < m31; i++)//объявляем цикл for 	
{
arr31_1[i] = arr31_1[i].innerHTML//получив массив из тегов говорим что значение этого тега присваивается значению элемента
}
console.log (arr31_1)//выводим элемент массива в консоль 

//Способ третий, можно воспользоваться методом Array.from:
let arr31_2 = Array.from(elems31);//в переменную записываем массив полученный из тегов параграыа с помощью метода  Array.from
console.log (arr31_2)//выводим в консоль

//_________________________________________________			
// 32 ТИПЫ ПСЕВДОМАССИВОВ В JS
let elem32 = document.querySelector('#parent32')//передаем в переменную значение  дива
let elems32_11 = elem32.getElementsByTagName('p');// HTMLCollection/получаем коллекцию тегов p
let elems32 = document.querySelectorAll('#parent32 p');// NodeList/получаем коллекцию тегов p
let p32 = document.createElement('p');//создаем тег параграфа p
elem32.append(p32)//|позиционируем тег p
p32.innerHTML = 88//передаем новому тегу значение
console.log(elems32)//выведем в консоль теги параграфа  [p, p, p, p, p]
console.log(elems32_11)//выведем в консоль теги параграфа  [p, p, p, p, p, p]

//_________________________________________________			
// 33 Коллекции Map 
//Пусть у нас есть некоторый объект: let obj = {a: 1, b: 2, c: 3};
//Как вы видите, в этом объекте есть пары ключ-значение. При этом ключами могут быть только примитивы: строки и числа.
//Иногда, однако, могут понадобится объекты, в которых ключом может быть любое значение: объект, массив или DOM элемент.
// Для этого в JavaScript существуют специальные коллекции Map. Давайте посмотрим, как с ними работать.
let elem33 = document.querySelector('#parent33')//передаем в переменную значение  дива
let map = new Map;//Создаем коллекцию с помощью команды new Map
//в коллекцию можно будет добавлять элементы с помощью метода set и получать их с помощью метода get.
let arr33_1 = [];//создаем массив
let arr33_2 = [3, 4];//создаем массив
let john33 = { name: "John" };//создаем объект
map.set(arr33_1, 'data1');//Присвоим нашим ключам некие значения (ключами коллекции):
map.set(arr33_2, 'data2');//Присвоим нашим ключам некие значения  (ключами коллекции):
map.set(john33, 'Alis');//Присвоим нашим ключам некие значения  (ключами коллекции)
console.log(map.get(arr33_1));//прочитаем наши значения по ключам, выведет data1
console.log(map.get(arr33_2));//прочитаем наши значения по ключам, выведет data2
console.log(map.get(john33));//прочитаем наши значения по ключам, выведет 'Alis'
elem33.innerHTML = map.get(john33);//прочитаем наши значения по ключам, в див передаем значение 'Alis'
console.log (arr33_1)//выведем в консоль название изначальных массивов, объектов и переменных -  0
console.log (arr33_2)//выведем в консоль название изначальных массивов, объектов и переменных - 3, 4
console.log (john33)//выведем в консоль название изначальных массивов, объектов и переменных - name: "John"
console.log(map);//выведет в консоль {Array(0) => "data1"} {Array(2) => "data2"}{Object => "Alis"}
//_________________________________________________			
// 34 Полезные свойства и методы коллекций map
//Коллекции Map имеют ряд полезных свойств и методов. В свойстве size содержится размер коллекции.
//Проверить наличие ключа в коллекции можно с помощью метода has. Удалить элемент из коллекции можно с помощью
// метода delete. Очистить всю коллекцию можно с помощью метода clear.
 let elem34 = document.querySelector('#parent34')//передаем в переменную значение  дива
 let elem34_1 = document.querySelector('#parent34_1')//передаем в переменную значение  дива
 let map34 = new Map;//Создаем коллекцию с помощью команды new Map
 let arr34 = {re: 'пн', 1: 'вт'};//создаем объект
 map34.set(arr34, 'data');//Присвоим нашим ключам некие значения:
 map34.set(1, "num1");  //Присвоим нашим ключам некие значения :цифра как ключ
map34.set(true, "bool1");  //Присвоим нашим ключам некие значения :булево значение как ключ
 console.log(map34.size);//определяет размер коллекии и выводим в консоль = 3
 let m34 = arr34[1]//в переменную передаем значение второго элемента объекта
console.log (m34)//выводим в консоль значение второго элемента объекта - 'вт'
 elem34.innerHTML = map34.get(arr34);//прочитаем наше значение по ключу arr34 , переданного в map и запишем в значение дива - 'data'
 elem34_1.innerHTML = map34.has(1);//Проверка наличия ключа , выведет true в экран если ключь 1 есть в коллекции map - true
 //map34.delete(arr34);//уeдаляет элемент из коллекции map
 //elem34.innerHTML = map34.get(arr34);//прочитаем наши значения по ключам, выведет undefined
   map34.clear();//Очищаем всю коллекцию
   console.log(map34.size);//определяет размер коллекии и выводим в консоль = 0
	
	//_________________________________________________			
// 35 Перебор коллекций Map циклом
let parent35 = document.querySelector('#parent35')//передаем в переменную значение дива
let map35 = new Map;//Создаем коллекцию с помощью команды new Map
let arr35_1 = [1, 2];//создаем массив
map35.set(arr35_1, 'data1');//Присвоим нашему ключу некое значение - 'data1'
for (let elem35 of map35) {//циклом перебираем коллекцию классов map35 - new Map
let p35 = document.createElement('p');//создаем тег параграфа - р, передаем в переменную
	console.log(elem35); // выводим в консоль сначала [[1, 2], 'data1']
	p35.innerHTML = elem35 //тегу параграфа присваиваем значение перебора коллекции классов Map
	parent35.append(p35);//позиционируем созданный тег параграфа
	}
	for (let [key, elem35] of map35) {//Можно отделить ключи и значения с помощью деструктуризации:
	console.log(key);//выведет в консоль [1, 2]
	console.log(elem35);//выведет в консоль'data1'
}	
console.log(arr35_1.length)//в переменную передаем длинну массива - 2 
console.log( map35.size) //выведет 1 так-как в коллекции всего один эелемент - arr35_1.'data1', массив [1, 2] в 
//коллекцию не входят

	//_________________________________________________			
// 36 Отделение ключей и значений в коллекциях Map
//Чтобы получить только ключи или только значения, существуют специальные методы. Для получения значений метод values().
//Аналогично с ключами - keys(). Метод entries, возвращает набор пар ключ-значение.
let parent36 = document.querySelector('#parent36')//передаем в переменную значение дива
let map36 = new Map;//Создаем коллекцию с помощью команды new Map
let arr36_1 = [4];//создаем массив
let arr36_2 = [5];//создаем массив
let arr36_3 = [6];//создаем массив
map36.set(arr36_1, " data1");//Присвоим нашим ключам  - arr36_1 некие значения "data1"
map36.set(arr36_2, ' data2');//Присвоим нашим ключам - arr36_2 некие значения ' data2'
map36.set(arr36_3, ' data3');//Присвоим нашим ключам - arr36_3 некие значения ' data3'
for (let elem36 of map36) {//циклом перебираем коллекцию классов
let p36 = document.createElement('p');//создаем тег параграфа - р, передаем в переменную
parent36.append(p36);//позиционируем созданный тег параграфа
p36.innerHTML = elem36//прочитаем наши значения по ключам из объекта map циклом по порядку
}
console.log ( map36.values());//передаем в консоль метод values,  получает только значения - {"data1", "data2", "data3"}
console.log ( map36.keys()); // получает только ключи {Array(1) [4], Array(1)[5], Array(1)[6]}
console.log ( map36.entries());//передаем в консоль метод entries, возвращает набор пар ключ-значение
//{Array(1) => " data1"}{Array(1) => " data2"}{Array(1) => " data3"}

	//_________________________________________________			
// 37 Применение коллекций Map
let parent37 = document.querySelector('#parent37')//передаем в переменную значение дива
let elems37 = parent37.getElementsByTagName('p');// HTMLCollection/получаем коллекцию тегов p
let map37 = new Map;//Создаем коллекцию с помощью команды new Map
let i37 = 1;//объявляем переменную - счетчик
for (let elem37 of elems37) {//перебираем циклом все теги p
map37.set(elem37, i37++);//передаем в коллекцию объект с значением 
elem37.addEventListener('click', function() {//при клике на тег p применяется функциональное выражение
this.textContent = this.textContent + map37.get(this);// свойство textContent выводит значение - аналог innerHTML
//говорим что значение элемента - параграф равен значению параграфа плюс map37.get(this) - который добавит значения от ключей 
//(счетчик 1, 2 ... при клике)
	});
}

	//_________________________________________________			
// 38 Коллекции Set
//В JavaScript существуют специальные коллекции Set, позволяющие создать массив без дублей.
let parent38 = document.querySelector('#parent38')//передаем в переменную значение дива
let i38 = 0//объявляем переменную i38 = 0
let m38 =[]//объявляем пустой массив
//Можно при создании заполнить коллекцию некоторыми значениями, передав параметром массив с данными
let set38 = new Set([1, 2, 3, 3, 4, 4, 5]);//Создаем коллекцию с помощью команды new Set
console.log(set38); // будет [1, 2, 3, 4, 5]
//После создания коллекции в нее можно добавлять новые элементы с помощью метода add
set38.add(0);//добавляем новый элемент в массив set
set38.add(2); // не добавится, тк уже есть
set38.add(3) // не добавится, тк уже есть
console.log(set38)// выведем в консоль массив в коллекции Set
set38.add(6);//добавляем новый элемент в массив set
set38.add(7);//добавляем новый элемент в массив set
set38.add(8)//добавляем новый элемент в массив set
set38.add(9);//добавляем новый элемент в массив set
set38.add(10)//добавляем новый элемент в массив set
console.log(set38)// выведем в консоль массив в коллекции Set
for (let elem38 of set38) {//перебираем циклом все теги p
console.log(elem38)//выводим в консоль каждый элемент из коллекции в консоль
m38[i38] = elem38//записываем в массив 
i38++//счетчик
}
parent38.innerHTML = m38//записываем в див полученный массив

//_________________________________________________			
// 39 Полезные свойства и методы коллекций Set
let parent39 = document.querySelector('#parent39')//передаем в переменную значение дива
let set39 = new Set([1, 2, 3, 3, 4, 4, 5]);//Создаем коллекцию с помощью команды new Set
let m39 =[]
set39.add(6);//добавляем новый элемент в массив set
set39.add(7);//добавляем новый элемент в массив set
set39.add(8);//добавляем новый элемент в массив set
set39.add(9);//добавляем новый элемент в массив set
set39.add(10);//добавляем новый элемент в массив set
set39.add(11);//добавляем новый элемент в массив set
set39.add(12);//добавляем новый элемент в массив set
//Размер коллекции - в свойстве size содержится размер коллекции:
console.log(set39.size); ///Размер коллекции - выедет в консоль 12
//Проверка наличия значения - проверить наличие значения в коллекции можно с помощью метода has:
console.log(set39.has(1));//Проверка наличия значения, выедет в консоль true
console.log(set39.has(0));//Проверка наличия значения, выедет в консоль false
//Удаление элементов - удалить элемент из коллекции можно с помощью метода delete
set39.delete(11); //удалит из коллекции элемент массива 11
set39.delete(12); //удалит из коллекции элемент массива 12
console.log(set39) //выедет в консоль [1, 2, 3, 3, 4, 4, 5, 6, 7, 8, 9, 10]

//_____3 способ___________
//let arr39 = [...set39];// заполняем массив деструктуризацией и оператором rest
//parent39.innerHTML = arr39 //выведет 1,2,3,4,5,6,7,8,9,10

//_____2 способ___________
let arr39 = Array.from(set39) //в переменную записываем массив полученный из тегов параграыа с помощью метода  Array.from
parent39.innerHTML = arr39 //выведет 1,2,3,4,5,6,7,8,9,10

//_____1 способ___________
//parent39.innerHTML = set39 //выведет [object Set]
//i39 = set39.size//получаем количество элементов в коллекции set
//for (let elem39 of set39)//перебираем коллекцию по элементам
//{
//--i39//уменьшаем счетчик
//m39[i39] = elem39//записываем каждый элемент в массив
//}
//parent39.innerHTML = m39 //выведет 10,9,8,7,6,5,4,3,2,1
//___________________________

//Очистка коллекции - очистить всю коллекцию можно с помощью метода clear:
set39.clear();//очисщаем всю коллекцию
console.log(set39)//выведет пустой массив

//_________________________________________________			
// 40 Перебор коллекций Set циклом
//данный способ хоть и прост, но решение с помощью оператором rest или с помощью метода Array.from компактней и предпочтительней
let parent40 = document.querySelector('#parent40')//передаем в переменную значение дива
let set40 = new Set([1, 2, 3, 3, 4, 4, 5]);//Создаем коллекцию с помощью команды new Set
set40.add(6);//добавляем новый элемент в массив set
set40.add(7);//добавляем новый элемент в массив set
set40.add(8);//добавляем новый элемент в массив set
set40.add(9);//добавляем новый элемент в массив set
set40.add(10);//добавляем новый элемент в массив set
i40 = set40.size//получаем количество элементов в коллекции set
let m40 =[]//создаем пустой массив
for (let elem40 of set40) {//перебираем коллекцию циклом for of
console.log(elem40);//выводим в консоль проверку
--i40//обратный счетчик
m40[i40] = elem40//записываем каждый элемент в массив
}
let reversed40 = m40.reverse();//применяем к массиву метод reverse() - разворачивает массив
parent40.innerHTML = reversed40//передаем массив в див, выведет 1,2,3,4,5,6,7,8,9,10

//_________________________________________________			
// 41 Преобразование коллекций Set
//Коллекции Set можно преобразовывать в массивы. Можно также выполнять обратную операцию - массивы преобразовывать в Set. 
//Преобразование в массив
let parent41_1 = document.querySelector('#parent41_1')//передаем в переменную значение дива
let parent41_2 = document.querySelector('#parent41_2')//передаем в переменную значение дива
let arr41 = [1, 2, 3];//объявляем массив с данными
let set41 = new Set(arr41);//передаем массив в параметр к коллекции set
let arr41_1 = [...set41];//заполняем массив деструктуризацией и оператором rest
let arr41_2 = Array.from(set41);//в переменную записываем массив с помощью метода  Array.from
parent41_1.innerHTML = arr41_1//выведет на экран 1,2,3
parent41_2.innerHTML = arr41_2//выведет на экран 1,2,3

//_________________________________________________			
// 42 Удаление дублей с помощью коллекций Set
//С помощью коллекций Set легко можно удалять дубли из массивов. Для этого массив нужно преобразовать в коллекцию Set. 
//Так как эта коллекция не может содержать дубли элементов, то при преобразовании они исчезнут. 
//Если затем преобразовать коллекцию обратно в массив, то мы получим массив без дублей.
let arr42_1 = [1, 2, 3, 1, 3, 4];//объявление массива
let res42_1 = [...new Set(arr42_1)];//передаем массив в параметр к коллекции set
console.log(res42_1); // выведет [1, 2, 3, 4] 

let set42 = new Set;//в переменную передаст объявленную коллекцию set
let button42 = document.querySelector('#parent42_3');//передаем в переменную значение кнопки
let elems42  = document.querySelectorAll('#parent42_2 p');//в переменную передаем значение тегов параграфа

for (let elem of elems42) {//циклом перебираем теги параграфа
	elem.addEventListener('click', function() {//навешиваем событие клика на функциональное выражение
		set42.add(this);//добавляем новый элемент в массив коллекцию set
		console.log (set42)//выводим в консоль значение коллекции
	});
}

button42.addEventListener('click', function() {//навешиваем событие клика на функциональное выражение к кнопке
	for (let elem of set42) {//перебираем коллекцию циклом 
		elem.textContent = elem.textContent + '!';//значению элемента добавляем !
		console.log (elem.textContent)//выводим в консоль значение элемента
	}
});

//_________________________________________________			
// 43 Массивы ArrayBuffer
//В JavaScript существует специальный массив ArrayBuffer, позволяющий хранить бинарные данные.
//Бинарные данные представляют собой набор байтов. Такие наборы возникают, к примеру, когда мы хотим прочитать какой-то
//файл или картинку и что-то с ними сделать, например, отправить через интернет. При создании такого массива мы должны указать, 
//сколько байтов мы хотим выделить для него:
let parent43 = document.querySelector('#parent43')//передаем в переменную значение дива
let buffer = new ArrayBuffer(8); // выделим 8 байтов
parent43.textContent = buffer;// выведет [object ArrayBuffer]

//_________________________________________________			
// 44 Итераторы
//Symbol - 6 примитивный тип данных, создает строку - уникальную переменную, нужен чтобы гарантировыть уникльность значения
//использован как идентификатор для свойств объектов
let sym44 = Symbol('необязательное описание');//создаем уникальную переменную
let sym44_2 = Symbol('необязательное описание');//создаем уникальную переменную
console.log (sym44)//вызовет Symbol(необязательное описание)
let obj44 = {a:1,b:2,c:3,sym44:function() {alert('7')},[sym44_2]:function() {alert('8')}}//создаем объект в котором одним из 
//элементов ключь будет функция
obj44['func'] = function() {console.log('5')}//добавляем в объект ключь со строкой и значением в виде функционального выражения
obj44[sym44] = function() {console.log('1')}//создаем уникальный ключъ со значением  '1'
console.log (obj44['func']) //выедет в консоль - ƒ () {console.log('5')}
for (let key in obj44)//циклом for in перебираем объекты
{
console.log (obj44[key]) //по порядку выведет 1,2,3,ƒ () {alert('7')},ƒ () {console.log('5')} - выведет все ключи кроме итерационного
}
console.log (obj44[sym44]) //выедет в консоль - ƒ () {alert('1')} - итератор (циклом он не выводится) только отдельно
console.log (obj44[sym44_2]) //выедет в консоль -ƒ () {alert('8')} - итератор (циклом он не выводится) только отдельно - 
//вариант прописан в объекте


//____well known symbols_____________
//Symbol.iterator - известный символ, задающий итератор объекта, используемый по умолчанию. Применяется в конструкции for...of.

let arr44_2 = [1,2,3]// создаем массив
console.log(arr44_2[Symbol.iterator]) //не выведет undefined или ошибку а выведет -ƒ values() { [native code] } - [Symbol.iterator] 
//- ключь не строка, представляет собой символ, уникальную сущность

let arr44_3 = [1,2,3]// создаем массив
console.log(arr44_3[Symbol.iterator]) //не выведет undefined или ошибку а выведет -ƒ values() { [native code] } - [Symbol.iterator] 
//- ключь не строка, представляет собой символ, уникальную сущность
let obj44_2 = {a: 1,b: 2,c: 3,d: 4,[Symbol.iterator]: function() {console.log('!')}//можем подставмить Symbol.iterator в 
//объект вместо ключа, , объявив его в скобках []
	};
for (let key in obj44_2)//перебираем объект циклом for...in
{
console.log (obj44_2 [key]) // 1,2,3,4
}
console.log (obj44_2 [Symbol.iterator])//выведет ƒ () {console.log('!')}

//______________________
//Symbol.for противоположен simbol и создает похожие значения
let leng44_2= Symbol.for('lang')//объявляем переменную с сущностью символом при каждом обращении нам гарантированно будет возвращаться
//один и тот же символ
let obj44_3= {1:'пн',2:'вт', 3:'cр'}//объявляем объект
obj44_3[leng44_2] ='ru'//в объекте создаем ключь с значением
console.log (obj44_3[leng44_2])//выведем в консоль -ru

function func44_1()//объявляем функцию
{
let lang44_1 = Symbol.for('pry') //создаем уникальную глобальную переменную
console.log (lang44_1)//выведет Symbol(pry)
return lang44_1 //выведет выполнение функции lang44_1
}

function func44_2 ()//объявляем функцию
{
let lang44_2 = Symbol.for('pry')//при втором вызове Symbol.for компелятор проверяет на наличие, если уже есть то вернет старое значением
console.log (lang44_2)//выведет Symbol(pry)
return lang44_2//вывод функции
}
console.log (func44_1 ()  === func44_2 ()) //выведет true
let parent44 = document.querySelector('#parent44')//передаем в переменную значение дива
//_______________

let m44 = 0//создаем счетчик переменную
let obj = {//создаем объект с Symbol.iterator
	a: 1,
	b: 2,
	c: 3,
	[Symbol.iterator]: function() {
		for (let key in  this) {//перебор объектов
			console.log(obj[key]);//вывод в консоль
			m44 += obj[key]//суммирование значений в переменную
		}
parent44.textContent = (m44);//передлаем значение в экран
	}
}
obj[Symbol.iterator]();//запустит функцию из значений к ключу


//_________________________________________________			
// 45 Введение в формат JSON 
//Иногда бывает нужно преобразовать некую структуру данных, например, массив или объект, в строку. Это может понадобится, 
//например, чтобы отправить эту структуру через интернет или сохранить в какое-то хранилище. Для этого в JavaScript 
//был придуман специальный формат JSON (произносится джейсон). Формат JSON может содержать одну из двух структур:
// или массив, или объект с парами ключ-значение. Массивы и объекты строятся так же, как и в JavaScript, но имеют ограничение:
// все строки и строковые ключи объектов должны быть взяты в двойные кавычки,

let json_45_1 = '[1, 2, 3, 4, 5, "a", "b"]';//строка, содержащя массив в формате JSON
console.log (json_45_1)//выведет список '[1, 2, 3, 4, 5, "a", "b"]'- последние 2 в формате JSON
let json_45_2 = `[//объявляем массив в котором объекты в формате JSON
	{
		"a": "aaa"//массив
		"b": "bbb"//массив
	},
	{
		"c": "ccc",//массив
		"d": "ddd"//массив
	}
]`;
console.log (json_45_2)//выведет список


//_________________________________________________			
// 46 Преобразование JSON в структуру данных
//С помощью метода JSON.parse можно преобразовать JSON в структуру данных JavaScript.
let json46 = '[1, 2, 3, 4, 5, "a", "b"]';
let arr46 = JSON.parse(json46);//С помощью метода JSON.parse  преобразуем JSON в структуру данных JavaScript.
console.log (arr46)// выведет массив в консоль [1, 2, 3, 4, 5, 'a', 'b']

//_________________________________________________			
// 47 Преобразование структур данных JavaScript в формат JSON
//С помощью метода JSON.stringify можно преобразовать массивы и объекты JavaScript в формат JSON. Давайте посмотрим на примере.
let arr47 = [1, 2, 3, 4, 5, 'a', 'b'];// запишеим в переменную массив
let json47 = JSON.stringify(arr47);//  преобразуем массив и объекты JavaScript в формат JSON и передаем в переменную
console.log (arr47) // выведет [1, 2, 3, 4, 5, 'a', 'b']
console.log (json47) //выведет [1,2,3,4,5,"a","b"]

//_________________________________________________			
// 48 Изменение данных в JSON
let json48 = '[1, 2, 3, 4, 5]';//передаем [1, 2, 3, 4, 5]
let arr48  = JSON.parse(json48);//С помощью метода JSON.parse  преобразуем JSON в структуру данных JavaScript.
arr48.push(6);//добавляем элемент в массив
let res48 = JSON.stringify(arr48);//  преобразуем массив и объекты JavaScript в формат JSON и передаем в переменную
console.log(res48);//выведет [1,2,3,4,5,6]

//_________________________________________________			
// 49 Основы работы с локальным хранилищем
//Сейчас мы с вами разберемся со специальным объектом localStorage, позволяющим хранить данные между заходами пользователя 
//на ваш сайт (5-10 мегабайт информации). Данные хранятся в специальном месте браузера под названием локальное хранилище.
//Доступ к данным производится по ключу: вы сохраняете данные с каким-то ключом, а затем можете получить их по этому ключу или удалить. 
//При этом разрешено сохранять только строки.

let time = localStorage.getItem('time');// получаем данные по ключу
let now  = (new Date()).getTime();//текущее время 
let date = (new Date(1992, 06, 20, 00, 00, 00)).getTime(); //время 20.06.1992
let diff = now - date;//переводим значения в timstemp, 
//определяем разницу в милисекундах
let year =  Math.round((diff / (1000 * 60 * 60*24 ))/365);//милисекунды в года и округляем по правилам методом Math.round
console.log (year);//выведет 29
localStorage.setItem('time', year);//сохраняем с ключом 'time' значение year в локальном хранилище браузера
console.log (time)//выведем в консоль кол-во лет

//Можно перезаписывать данные, хранящиеся под определенным ключом
localStorage.setItem('time', 1);//сохраняем с ключом 'time' значение 1 в локальном хранилище браузера
let value46 = localStorage.getItem('time');// получаем данные по ключу
console.log(value46); // выведет в консоль 1

localStorage.setItem('time', 2);//сохраняем с ключом 'time' значение 2 в локальном хранилище браузера
let value47 = localStorage.getItem('time');// получаем данные по ключу
console.log(value47); // выведет в консоль 2

//С помощью метода removeItem можно удалять данные и связанный с ними ключ. 
localStorage.removeItem('key');//удаляем с ключом 'key' все связанные значения в локальном хранилище браузера
let value = localStorage.getItem('key');// получаем данные по ключу
console.log(value); // выведет в консоль null

//С помощью метода clear можно очистить все хранилище. 
localStorage.clear();// методом clear к объекту localStorage очищаем все хранилище.
let value49 = localStorage.getItem('key');// получаем данные по ключу
console.log(value49); // выведет в консоль null

//_________________________________________________			
// 50 Хранение массивов и объектов в локальном хранилище

let arr50 = [1, 2, 3, 4, 5];
localStorage.setItem('arr50', JSON.stringify(arr50));//сохраняем с ключом 'arr50' значение JSON.stringify(arr50) в локальном хранилище браузера, 
//  преобразуем массив и объекты JavaScript в формат JSON и передаем в локальное хранилище
let str50 = localStorage.getItem('arr50');// получаем данные по ключу
let res50 = JSON.parse(str50);//С помощью метода JSON.parse  преобразуем JSON в структуру данных JavaScript.
console.log(str50); //выводим в консоль строку[1,2,3,4,5];
console.log(res50); //выводим в консоль массив [1, 2, 3, 4, 5];

let users50 = [//создаем массив с объектами
	{
		surname: 'surname1',
		name: 'name1',
		age: 31,
	},
	{
		surname: 'surname2',
		name: 'name2',
		age: 32,
	},
	{
		surname: 'surname3',
		name: 'name3',
		age: 33,
	},
];
let elem50_4 = document.querySelector('#elem50_4');//объявляем кнопку по id
elem50_4.addEventListener('click', function() {//навешиваем событие клика на кнопку
let object50 = {}//создаем пустой объект
let elem50_1 = document.querySelector('#elem50_1');//объявляем область ввода
surname50 = elem50_1.value//объявляем переменную куда записываем значение из области ввода
let elem50_2 = document.querySelector('#elem50_2');//объявляем область ввода
name50 = elem50_2.value//объявляем переменную куда записываем значение из области ввода
let elem50_3 = document.querySelector('#elem50_3');//объявляем область ввода
age50 = elem50_3.value//объявляем переменную куда записываем значение из области ввода
object50.surname = surname50//записываем в пустой объект ключь surname с значением 
object50.name = name50//записываем в пустой объект ключь name с значением 
object50.age = age50//записываем в пустой объект ключь age с значением 
users50.push(object50)//добавляем в массив одним из элементов
console.log (users50)//выводим массив 
localStorage.setItem('users50', JSON.stringify(users50)) //сохраняем с ключом 'users50' значение из  локального хранилища браузера
let value50 = localStorage.getItem('users50');// получаем данные по ключу
console.log(value50); // выведет все объекты (свои элнмен
});

//_________________________________________________			
// 51 Обработка исключительных ситуаций 

//Существуют специальные конструкция try-catch, который вываливает ошибку в консоль и прекращает дальнейшее выполнение скрипта.
try {//пытаемся прогнать скрипт на ошибку
	let data51 = JSON.parse('{1,2,3,4,5}');// данный json некорректен, должен преобразовывать JSON в структуру данных JavaScript, но 
	//элементы заковычены, это не массив поэтому ошибка
} catch (error) {//конструкция try-catch
	console.log('невозможно выполнить операцию разбора JSON');//выводит в консоль строку если произойдет ошибка
}
//Вложенность кода
//Особенность и удобство исключений заключаются в том, что их можно ловить при любом уровне вложенности кода. Посмотрим на примере.
// Пусть у нас есть функция, сохраняющая данные в локальное хранилище:
function save51(str51) {// объявляем функцию
	localStorage.setItem('key', str51);//сохраняем с ключом 'key' значение из  локального хранилища браузера
}
try {//пытаемся прогнать скрипт на ошибку
let str51 = '';//создаем пустую строку
for (let i = 1; i <= 6 * 10 ** 6; i++) { // формируем строку более 5 мб
	str51 += '+';//складываем в строку
}
	save51(str51);//выполняем функцию с переданными параметрами
} catch (error) {//выводим ошибку
	console.log('закончилось место в локальном хранилище!');//вывод ошибки в консоль
}

//_________________________________________________			
// 52 Обработка исключительных ситуаций 
try {//конструкция try-catch
	let data52 = JSON.parse('{1,2,3,4,5}');// данный json некорректен, должен преобразовывать JSON в структуру данных JavaScript, но 
	//элементы не заковычены "" что является ошибкой
} 
catch (error) {//конструкция try-catch
	console.log('невозможно выполнить операцию разбора JSON');//выводит в консоль строку если произойдет ошибка
	console.log(error.name); // имя ошибки.- SyntaxError
	console.log(error.message); // текст ошибки - Unexpected number in JSON at position 1
}
//_____________

function saveData52(json) {//объявляем функцию
	try {//пытаемся прогнать скрипт на ошибку
		let arr = JSON.parse(json);//преобразуем формат JSON в формат JS - массив
		
		for (let i = 0; i < arr.length; i++) {//цикл счетчик
			try//пытаемся прогнать скрипт на ошибку
			{
			localStorage.setItem(i, arr[i]);//загрудаем в буфер по ключу i значение элемента из массива
			} 
			catch (error) //выводим ошибку
			{
			console.log('закончилось место в хранилище');//выводим ошибку в консоль
			}
		}
	} 
	catch (error) //выводим ошибку
	{
	console.log('некорректный JSON');//выводим ошибку в консоль
	}
}
saveData52('[1, 2, 3, 4, 5, "a", "b"]')//ошибку не дает
saveData52('{1,2,3,4,5}')//некорректный JSON

//_________________________________________________			
// 53 Обработка исключительных ситуаций 
//В  проекте могут быть и другие ситуации, которые для нас являются исключительными, а для JavaScript - нет. 
//В таком случае мы можете создавать и выбрасывать свои, пользовательские исключения. Для начала исключение нужно создать с 
//помощью команды new Error, параметром передав текст исключения:
//new Error('необязательный текст')-создаем новый проект
//throw new Error('текст исключения') -исключение нужно выбросить с помощью команды throw

function div53(a, b) {//объявляем функционкцию 
	if (b !== 0) {//условие если b не равно 0
		return a / b;//вывести результатом функции a / b
	} else {//в противном случае
		throw new Error('ошибка деления на ноль');//бросить новую ошибку 
	}
}
try {
	console.log( div53(3, 0) );//выполняемый скрипт , анализируемый на ошибку
} 
catch (error) {//выводим ошибку
	console.log('вы пытаетесь делить на 0, что запрещено');//выводим ошибку в консоль
}

//_____________

try {//пытаемся прогнать скрипт на ошибку
	throw {name: 'MyError53', message: 'текст исключения'};//указываем бросаем сами название и тип исключения
	
} catch (error) {//проверяем ловим на ошибку
	console.log(error.name); // 'MyError53'
	console.log(error.message); // 'текст исключения'
}

//________________

let product53 = document.querySelector('#product53');//записываем значение тега div в переменную
try {//пытаемся прогнать скрипт на ошибку
let cost53 = getCost53(product53);//выполняем функцию а результат запишем в переменную
function getCost53(elem) {//объявляем функцию
	if (elem.dataset.price53 !== undefined //условие если значение в атрибуте не неопределено
		&& elem.dataset.amount53 !== undefined) { //условие если значение в атрибуте не неопределено
	return elem.dataset.price53 * elem.dataset.amount53;//то переумножаем значения и передаем в результат функции
}
 else {//в противном случае 
 //return 0;//выводим 0
 throw {//выбрасываем ошибку 
			name: 'ProductCostError',//имя ошибки 
			message: 'отсутствует цена или количество у продукта'//текст ошибки
		};
}
}
console.log(cost53);//выводим в консоль результат функции
product53.textContent = cost53;//передаем в значение результат функции
} catch (error) {//ловим ошибку
	console.log(error.name); //в консоль выводим ошибку
	product53.textContent = error.message; //в значение тега div выводим ошибку
}

//_________________________________________________			
// 54 Основы работы с терминалом (командная строка, PowerShell

//____Переход по каталогам____
//Если вы работаете в командной строке (CMD), то для перехода в другую папку нужно ввести команду CD и название папки. Например,
//Если вы находитесь в корне диска C и хотите перейти в папку Users, то вам нужно вводить команду: cd Users.
//Для того чтобы вернуться назад (перейти на уровень выше по дереву папок) нужно вводить команду: cd ..
//Для того чтобы быстро перейти в корневый каталог текущего диска нужно выполнить: cd \
//Для перехода на более нижний уровень: cd aaa
//Если вам нужно перейти на другой диск, например, с диска C на диск D, то команду cd нужно выполнять с параметром cd /D A:
//Например, если вам нужно перейти с диска C на диск D в папку GAMES, то вам нужно ввести команду: cd /D A:\games
//Можно выходить на сколько угодно уровней вверх: cd C:\OpenServer\domains\ert\xxx\aaa\..\bbb 

//____Полный текущий путь______
//С помощью команды pwd можно узнать абсолютный путь относительно корня операционной системы к текущему рабочему каталогу:
//PS C:\OpenServer\domains\ert\xxx\bbb> pwd

//_____Просмотр содержимого каталога_________
//Команда ls для PS , dir для CL используется для просмотра содержимого каталога:
//PS C:\OpenServer\domains\ert\xxx\bbb> ls
// команда также выведет список всех файлов в подкаталогах ls -R:
//PS C:\OpenServer\domains\ert\xxx\bbb> ls -R
//dir для CL используется для просмотра содержимого каталога:
//CL C:\OpenServer\domains\ert\xxx\bbb>dir

//_____Просмотр содержимого файла___________
//Команда cat используется для просмотра содержимого файла, выводя его прямо в терминал:
//PS C:\OpenServer\domains\ert\xxx\aaa> cat zzz.txt //привет я Владик
//CL C:\OpenServer\domains\ert\xxx\aaa> type zzz.txt //helo (кирилицу не читает)
//PS C:\OpenServer\domains\ert> cat xxx\aaa\zzz.txt //привет я Владик

//_____Создание файла___________
//С помощью команды cat для PS и echo для CL можно создавать новые файлы:
//PS C:\OpenServer\domains\ert\xxx\aaa> cat > ccc.txt
//CL C:\OpenServer\domains\ert\xxx\bbb> echo этот_текст_будет_содержать_файл > MyFile.txt

//_______Копирование файла___________
//Команда cp для PS и copy для CL выполняет копирование файла. Первым параметром она принимает путь к файлу,
// который мы хотим копировать, а вторым - путь, по которому мы хотим создать копию файла:
//PS C:\OpenServer\domains\ert\xxx> cp aaa/dddd.html bbb/copy.html
//CL copy C:\OpenServer\domains\ert\xxx\aaa\ui.txt C:\OpenServer\domains\ert\xxx\bbb

//__________Создание каталога_________
//Команда mkdir выполняет создание новой папки как в PS так и CL:
//PS|CL C:\OpenServer\domains\ert\xxx> mkdir testtest

//___________Удаление каталога_________
//Для CL Команда RD (RMDIR) удаляет каталог/папку через командную строку. 
//Ключь /S - Удаление дерева каталогов, т. е. не только указанного каталога, но и всех содержащихся в нем файлов и подкаталогов.
//Ключь /Q - Отключение запроса подтверждения при удалении дерева каталогов с помощью ключа /S.
//CL RD /s/q test
//Для PS Команда rm используется для удаления каталогов и содержимого внутри них:
//PS C:\OpenServer\domains\ert\xxx> rm test

//___________Удаление файлов_________
//Команда del удаляет файлы и в командной строке и в PowerShell
//PS|CL C:\OpenServer\domains\ert\xxx\aaa> del zzz.txt

//_________________________________________________			
// 55 Введение в инструмент NodeJS
//NodeJS представляет собой JavaScript, выполняемый на сервере. Под сервером подразумевается специальный компьютер в интернете,
//на котором будет размещаться ваш сайт. Сервером можно сделать и тот компьютер, на котором ведется разработка сайта.
//NodeJS позволяет средствами сервера генерировать HTML код, который затем будет отправлен в браузер (на клиент). 
//Кроме того, NodeJS позволяет работать с базой данных и с файловой системой сервера. Кроме того, NodeJS является средой,
//в которой на вашем компьютере будут запускаться удобные инструменты NodeJS.




	</script>	
	</body>
</html>